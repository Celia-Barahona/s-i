<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Puzzle</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: #f9f9f9;
      flex-direction: column;
    }

    h1 {
      font-size: 2em;
      color: #4479a3;
      margin-bottom: 20px;
    }

    .puzzle-container {
      display: grid;
      grid-template-columns: repeat(4, 100px);
      grid-template-rows: repeat(4, 100px);
      gap: 5px;
    }

    .puzzle-piece {
      width: 100px;
      height: 100px;
      cursor: pointer;
      background-size: 400px 400px;
      border: 1px solid #ddd;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 0;
    }

    .empty {
      background-color: #f9f9f9;
      cursor: default;
      border: 1px dashed #aaa;
    }

    #victoryMessage {
      display: none;
      margin-top: 20px;
      color: green;
      font-size: 1.5em;
    }
  </style>
</head>
<body>
  <h1>ðŸ§© Resuelve el Puzzle</h1>
  <div class="puzzle-container" id="puzzleContainer"></div>
  <div id="victoryMessage">ðŸŽ‰ Â¡Felicidades! Has resuelto el puzzle. ðŸŽ‰</div>

  <script>
    const imageSrc = './img/Silvia.png'; // Ruta de la imagen
    const puzzleContainer = document.getElementById('puzzleContainer');
    const victoryMessage = document.getElementById('victoryMessage');

    let emptyPosition = { row: 3, col: 3 }; // La posiciÃ³n vacÃ­a inicial (Ãºltima pieza)
    const gridSize = 4;
    let puzzleInitialized = false;

    // Crear las piezas del puzzle
    const createPuzzle = () => {
      const pieces = [];
      let index = 0;

      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          const piece = document.createElement('div');
          piece.classList.add('puzzle-piece');
          piece.dataset.position = `${row}-${col}`; // Asignar posiciÃ³n inicial

          // Ãšltima pieza es el espacio vacÃ­o
          if (row === gridSize - 1 && col === gridSize - 1) {
            piece.classList.add('empty');
            pieces.push(piece);
            continue;
          }

          piece.style.backgroundImage = `url(${imageSrc})`;
          piece.style.backgroundPosition = `-${col * 100}px -${row * 100}px`;
          piece.dataset.index = index;
          pieces.push(piece);
          index++;
        }
      }

      // Mezclar las piezas hasta que no estÃ©n en un estado resuelto
      do {
        pieces.sort(() => Math.random() - 0.5);
      } while (isPuzzleSolved(pieces));

      // AÃ±adir piezas al contenedor
      pieces.forEach(piece => puzzleContainer.appendChild(piece));
      puzzleInitialized = true; // Marcar el puzzle como inicializado
    };

    // Verificar si el puzzle estÃ¡ resuelto
    const isPuzzleSolved = (pieces = Array.from(document.querySelectorAll('.puzzle-piece'))) => {
      return pieces.every((piece, index) => {
        const expectedRow = Math.floor(index / gridSize);
        const expectedCol = index % gridSize;
        const [currentRow, currentCol] = piece.dataset.position.split('-').map(Number);
        return currentRow === expectedRow && currentCol === expectedCol;
      });
    };

    const checkVictory = () => {
      if (puzzleInitialized && isPuzzleSolved()) {
        victoryMessage.style.display = 'block';
      }
    };

    // Mover una pieza si es adyacente al espacio vacÃ­o
    const movePiece = (piece) => {
      const [pieceRow, pieceCol] = piece.dataset.position.split('-').map(Number);
      const { row: emptyRow, col: emptyCol } = emptyPosition;

      const isAdjacent =
        (pieceRow === emptyRow && Math.abs(pieceCol - emptyCol) === 1) ||
        (pieceCol === emptyCol && Math.abs(pieceRow - emptyRow) === 1);

      if (isAdjacent) {
        // Intercambiar posiciones
        piece.dataset.position = `${emptyRow}-${emptyCol}`;
        emptyPosition = { row: pieceRow, col: pieceCol };

        const emptyPiece = document.querySelector('.empty');
        emptyPiece.dataset.position = `${pieceRow}-${pieceCol}`;

        // Reordenar las piezas en el DOM
        reorderPieces();

        // Verificar si el puzzle estÃ¡ resuelto
        checkVictory();
      }
    };

    // Reordenar las piezas en el DOM segÃºn sus posiciones
    const reorderPieces = () => {
      const pieces = Array.from(document.querySelectorAll('.puzzle-piece'));
      pieces.sort((a, b) => {
        const [aRow, aCol] = a.dataset.position.split('-').map(Number);
        const [bRow, bCol] = b.dataset.position.split('-').map(Number);
        return aRow * gridSize + aCol - (bRow * gridSize + bCol);
      });
      puzzleContainer.innerHTML = '';
      pieces.forEach(piece => puzzleContainer.appendChild(piece));
    };

    // Inicializar el puzzle
    window.addEventListener('DOMContentLoaded', () => {
      createPuzzle();

      // Hacer las piezas clicables
      puzzleContainer.addEventListener('click', (e) => {
        const piece = e.target;

        // Validar que se haya hecho clic en una pieza
        if (!piece.classList.contains('puzzle-piece') || piece.classList.contains('empty')) {
          return;
        }

        movePiece(piece);
      });
    });
  </script>
</body>
</html>
