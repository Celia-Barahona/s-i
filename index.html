<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Puzzle</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: #f9f9f9;
      flex-direction: column;
    }

    h1 {
      font-size: 2em;
      color: #4479a3;
      margin-bottom: 20px;
    }

    .puzzle-container {
      display: grid;
      grid-template-columns: repeat(4, 100px);
      grid-template-rows: repeat(4, 100px);
      gap: 5px;
    }

    .puzzle-piece {
      width: 100px;
      height: 100px;
      cursor: pointer;
      background-size: 400px 400px;
      border: 1px solid #ddd;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 0;
    }

    .empty {
      background-color: #f9f9f9;
      cursor: default;
      border: 1px dashed #aaa;
    }

    #victoryMessage {
      display: none;
      margin-top: 20px;
      color: green;
      font-size: 1.5em;
    }
  </style>
</head>
<body>
  <h1>ðŸ§© Resuelve el Puzzle</h1>
  <div class="puzzle-container" id="puzzleContainer"></div>
  <div id="victoryMessage">ðŸŽ‰ Â¡Felicidades! Has resuelto el puzzle. ðŸŽ‰</div>

  <script>
    const imageSrc = './img/Silvia.png'; // Ruta de la imagen
    const puzzleContainer = document.getElementById('puzzleContainer');
    const victoryMessage = document.getElementById('victoryMessage');

    let emptyPosition = { row: 3, col: 3 }; // La posiciÃ³n vacÃ­a inicial (Ãºltima pieza)
    const gridSize = 4;
    let puzzleInitialized = false;

    // Crear las piezas del puzzle
    const createPuzzle = () => {
      const pieces = [];
      let index = 0;

      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          const piece = document.createElement('div');
          piece.classList.add('puzzle-piece');

          // Asignar la posiciÃ³n objetivo (posiciÃ³n correcta)
          piece.dataset.targetPosition = `${row}-${col}`;

          // Asignar la posiciÃ³n actual (posiciÃ³n inicial)
          piece.dataset.currentPosition = `${row}-${col}`;

          // Ãšltima pieza es el espacio vacÃ­o
          if (row === gridSize - 1 && col === gridSize - 1) {
            piece.classList.add('empty');
            continue;
          }

          // Estilo de la imagen para cada pieza
          piece.style.backgroundImage = `url(${imageSrc})`;
          piece.style.backgroundPosition = `-${col * 100}px -${row * 100}px`;
          piece.dataset.index = index;
          pieces.push(piece);
          index++;
        }
      }

      // Mezclar las piezas hasta que el puzzle no estÃ© en un estado resuelto
      do {
        shufflePieces(pieces);
      } while (isSolved(pieces));

      // AÃ±adir piezas al contenedor
      pieces.forEach(piece => puzzleContainer.appendChild(piece));
      puzzleInitialized = true; // Marcar el puzzle como inicializado
    };

    // Mezclar las piezas
    const shufflePieces = (pieces) => {
      for (let i = pieces.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
      }

      // Actualizar las posiciones actuales tras mezclar
      pieces.forEach((piece, index) => {
        const row = Math.floor(index / gridSize);
        const col = index % gridSize;
        piece.dataset.currentPosition = `${row}-${col}`;
      });
    };

    // Verificar si el puzzle estÃ¡ resuelto
    const isSolved = (pieces = Array.from(document.querySelectorAll('.puzzle-piece'))) => {
      return pieces.every(piece => {
        return piece.dataset.currentPosition === piece.dataset.targetPosition;
      });
    };

    // Mover una pieza si es adyacente al espacio vacÃ­o
    const movePiece = (piece) => {
      // Obtener la posiciÃ³n actual de la pieza seleccionada
      const [pieceRow, pieceCol] = piece.dataset.currentPosition.split('-').map(Number);
      const { row: emptyRow, col: emptyCol } = emptyPosition;

      console.log(`Pieza seleccionada: (${pieceRow}, ${pieceCol})`);
      console.log(`PosiciÃ³n vacÃ­a: (${emptyRow}, ${emptyCol})`);

      // Verificar si la pieza es adyacente a la vacÃ­a
      const isAdjacent =
        (pieceRow === emptyRow && Math.abs(pieceCol - emptyCol) === 1) || // Misma fila, columnas adyacentes
        (pieceCol === emptyCol && Math.abs(pieceRow - emptyRow) === 1);   // Misma columna, filas adyacentes

      if (isAdjacent) {
        console.log('La pieza es adyacente. Moviendo pieza...');

        // Obtener la pieza vacÃ­a
        const emptyPiece = document.querySelector('.empty');

        // Validar si el espacio vacÃ­o existe en el DOM
        if (!emptyPiece) {
          console.error('Error: No se encontrÃ³ el espacio vacÃ­o en el puzzle.');
          return;
        }

        // Intercambiar posiciones entre la pieza seleccionada y la vacÃ­a
        piece.dataset.currentPosition = `${emptyRow}-${emptyCol}`;
        emptyPiece.dataset.currentPosition = `${pieceRow}-${pieceCol}`;
        emptyPosition = { row: pieceRow, col: pieceCol }; // Actualizar posiciÃ³n de la vacÃ­a

        // Reasignar las clases
        piece.classList.add('empty');
        emptyPiece.classList.remove('empty');

        console.log(`Nueva posiciÃ³n de la pieza vacÃ­a: (${emptyPosition.row}, ${emptyPosition.col})`);

        // Reordenar las piezas en el DOM
        reorderPieces();

        // Verificar si el puzzle estÃ¡ resuelto
        if (isSolved()) {
          victoryMessage.style.display = 'block';
        }
      } else {
        console.log('La pieza seleccionada no es adyacente a la vacÃ­a.');
      }
    };

    // Reordenar las piezas en el DOM segÃºn sus posiciones actuales
    const reorderPieces = () => {
      const pieces = Array.from(document.querySelectorAll('.puzzle-piece'));
      pieces.sort((a, b) => {
        const [aRow, aCol] = a.dataset.currentPosition.split('-').map(Number);
        const [bRow, bCol] = b.dataset.currentPosition.split('-').map(Number);
        return aRow * gridSize + aCol - (bRow * gridSize + bCol);
      });

      // Vaciar el contenedor y volver a agregar las piezas ordenadas
      puzzleContainer.innerHTML = '';
      pieces.forEach(piece => puzzleContainer.appendChild(piece));
    };

    // Inicializar el puzzle
    window.addEventListener('DOMContentLoaded', () => {
      createPuzzle();

      // Hacer las piezas clicables
      puzzleContainer.addEventListener('click', (e) => {
        const piece = e.target;

        // Validar que se haya hecho clic en una pieza
        if (!piece.classList.contains('puzzle-piece') || piece.classList.contains('empty')) {
          return;
        }

        movePiece(piece);
      });
    });
  </script>
</body>
</html>
